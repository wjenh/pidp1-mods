SELECT AND RUN A DRUMLOADER PROGRAM VIA REMOTE CONNECTION ASCII VERSION

// This uses the IOT 61 Drum implementation to query for, load,
// and run a program from the drum.
// It can also label a program, or list available programs.
// When started, it listens on port 2022 for a connection.
// When a program is requested, it copies the core image from the drum to bank 0 and
// replaces the default binloader at 7751 with its bank 0 control code, 
// It then sets up interrupt block 0, enables interrupts, closes the remote connection,
// and transfers control to the program.
// When a new connection comes in, it repeats the query for a new program to run.
// If the loaded program halts or overwrites 7751 and up,
// you can restart this at location 100 in the specified bank.
// It also uses IOT 22, DCS2, and IOT 32, timesharing clock.

// These are pure defines, no code
#include <DRUM/type23drumdefs.ah>
#include <DCS/dcs2defs.ah>
#include <CLOCK/clockdefs.ah>
#include <memory.ah>

// Which bank we load the control program into
#define bnkno 1
// A scratch buffer at 3000 is used for reading a line.
#define linbuf 3000

bank bnkno

// Put our included code bits here
1000/
#include <DCS/getach.ah>
#include <DCS/getaln.ah>
#include <DCS/textascii.ah>
#include <getnum.ah>
#include <memcpy.ah>

#define say(a) law a; jda txtasc
#define newline law '\n'; lia ; iot tcb

// An image of what gets copied down to bank 0 is kept in this bank, not used except for the transfer.
// DCS2 is using channel interrupts.
0/
    lem
    jmp runprog
    0
    jmp isr

// When running, the bank 0 code will transfer here on interrupt, a channel connect.
100/
resume, lsm         // no interrupts for now
     cbs
     lem            // extended mem off so we don't screw up local indirects
     cli
     iot rci        // clear the DCS2 interrupt flag, chan 0
// Be sure we actually open and have a connection
// If not open, do so
// If open and not connected, wait for one
rs2, cli
     iot rcs        // get channel status for chan 0
     lai
     and [dsfopn
     sza
     jmp rs3
     lio [sbcset ctl]    // not open, do so, listens on port 2022 decimal.
     iot scb

rs3, cli            // loop waiting for a connection, which will be ready if we got here via the interrupt
     iot rcs
     lai
     and [dsfcon
     sza i
     jmp rs3

// lock the send channel to 0 
     cli
     iot ssb
     say(hl1)       // we're connected, say hello and proceed
     say(hl1b)
     say(hl1c)

// Get the track to load or the command
// If not valid, ask again
// If a fatal error occurs, halt then rebind and go back to the connection wait
try, say(hl2)
     lio [linbuf
     jda getaln
     lai
     sza
     jmp dcsfal     // got an error, probably a client disconnect
     newline
     lio [linbuf
     jda getnum
// AC has number, IO neg if no number, char in low bits
     spi i
     jmp doload
     lai
     and [377
     sad ['h']       // yes, it's ascii on a PDP-1
     jmp stop
     sad ['l'
     jmp list
     say(badnum)
     jmp try        // not a recognized command or number, try again
stop, lio [sbcrst]    // completely shut down DCS2
     iot scb
     hlt
     jmp resume     // ok, they really want to continue

// List programs on the drum
// Loop thru all tracks getting the control block, 7751-7777
list,
     newline
     dzm trk
lst2, lac trk
     sal 6s
     sal 6s
     ior [drmrd 7751] // directory area on the drum track
     lia
     iot dia
     law 26         // read o26 words
     lia
     iot dwc
     law linbuf     // into our buffer
     ior [0:bnkno]  // because law only does 12 bits
     lia
     iot dcl
     lac linbuf+25  // 707070 is a marker that the track has an image
     sad [707070
     jmp .+2
     jmp next
     jda prttrk
     say(dir)
     say(linbuf)
     newline
next, idx trk       // next drum track
     sad [040
     jmp try        // done with listing
     jmp lst2
trk, 0

// AC has the track to load.
// Load bank 0 mem from drum,the entire track.
// Drum uses dma, no need for eem yet.
doload,
     sal 6s
     sal 6s
     ior [drmrd
     lia
     iot dia
     cli            // a word count of 0 means 4096 words
     iot dwc
     iot dcl        // bank 0, address 0

// Bank 0 now has pgm loaded, check for valid load entry.
// We need eem briefly to access location 7777 in bank 0 just to verify it.
     eem
     farlac(7777)    // nifty macro from memory.ah
     lem
     sad [707070
     jmp trkok
     say(inval)
     jmp try

// say the pgm, copy our bank 0 stuff again
trkok,
     say(bye)

// show the directory filename, in bank 0 7751
// we need it in this bank
     law 24
     jda memcpy     // eem must be off for memcpy
         7751
         linbuf:bnkno
     say(linbuf)
     say(bye2)

// copy our low mem code, 0 to 0
// remember that is is a full address copy
     law 4
     jda memcpy
         0:bnkno
         0

// copy our high mem code
     law 20
     jda memcpy
         isr:bnkno
         isr

// start 2 second countdown
     law 0d2000     // 2k milliseconds
     iot i cct      // start 1msec countdown timer and wait
     cla
     iot cct        // disable timer

// Close the channel, it will reopen on the next connection
     lio [sbcbnd
     iot scb
// be sure things are cleaned up interrupt-wise
     cbs
     cli
     iot rci
// and transfer back to bank 0
     eem
     farjmp(runprog)   // another cool macro

// we had an error, just rebind and wait
dcsfal, lio [sbcbnd
     iot scb
     hlt
     jmp resume

// We initially reset the DCS system for a clean start
boot,
    lem
    lio [sbcrst
    iot scb
    jmp resume

hl1,
    ascii "Hello from your PiDP1!\n"
hl1b,
    ascii "Once you select a program, this connection will close.\n"
hl1c,
    ascii "Open it again to select a new program.\n"
hl2,
    ascii "Program number to load, 0-31, l to list available,\nor h to close all connections and halt? "

dir,
    ascii " - "

badnum,
    ascii "Sorry, that's not a valid number, try again.\n"
inval,
    ascii "That track does not have a program loaded, try again.\n"

bye,
    ascii "\nLoading program "
bye2,
    ascii " then closing.\n"

// Print the track number in location trk as 2 decimal digits.
prttrk, 0
    dap prtrtn
    cla
    lio trk
    sil 1s
    div [0d10
    add ['0'
    lsw
    iot tcb
    add ['0'
    lia
    iot tcb
prtrtn, jmp .

// server port, ascii, echo, and crlf on channel 0, interrupt on connect or disconnect
// listen on port 2022
ctl, dcfcrnl dcfecho dcfsrv dcfie dcfioe dcfioc
     0d2022
     octal

// put our contants out here so they don't mess up high memory
constants

// The bank 0 control transfer back to bank 1.
// Resides in the usual loader area starting at 7751.
// It's here for easy copying to 0.
7751/
// A connect request comes here, isr, 7751.
// We have to jump thru hoops jumping to rti
// because you can't enable extended mem while in
// the interrupt and have it stick.
isr, law rtn
     dac 1          // fake the return from interrupt addr back here
     jmp i 1

// The above ends up here, rtn, 7754. The jmp i 1 dismissed the interrupt.
// Enable extened memory and jump back to our control code.
rtn, eem
     farjmp(resume:bnkno)

// The controller jumps here, runprog to start the program.
// Be sure to not overwrite 7773-7777!
// 7773 was loaded with the program start addr from the drum.
runprog, lem
    esm
    jmp i sadr
7773/
sadr, 0

start boot:1
