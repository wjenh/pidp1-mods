SELECT AND RUN A DRUMLOADER PROGRAM VIA REMOTE CONNECTION ASCII VERSION

/ This uses the IOT 61 Drum implementation to query for, load,
/ and run a program from the drum.
/ It can also label a program, or list available programs.
/ When started, it copies its control code to bank 'bank', below,
/ When a program is requested, it copies the core image from the drum to bank 0 and
/ replaces the default binloader at 7751 with its bank 0 control code, 
/ It then sets up interrupt block 0, enables interrupts, closes the remote connection,
/ and transfers control to the program.
/ When a new connection comes in, it repeats the query for a new program to run.
/ If the loaded program halts or overwrites 7751 and up,
/ you can restart this at location 100 in the specified bank.

#include <1Dinstructions.mh>
#include <DRUM/type23drumdefs.mh>
#include <DCS/dcs2defs.mh>
#include <CLOCK/clockdefs.mh>

/ Which bank we load the control program into
bnk=10000
bnkno=1
isr=7751
rtn=7754
strt=7765
sadr=7773

/ A scratch buffer at 500 is used for reading a line.
linbuf=500

/ Put our included code bits here
1000/
#include <DCS/getach.mh>
#include <DCS/getaln.mh>
#include <DCS/textascii.mh>
#include <getnum.mh>

define say a
    law a
    ior (bnk
    jda txtasc
    term

/ DCS2 is using channel interrupts
0/
    lem
    jmp strt
    0
    jmp isr

/ We don't initially start here, just convenient for copying to the extended bank.
/ When running, the bank 0 code will transfer here on interrupt, a channel connect.
100/
resume, lsm
     cbs
     cli
     iot rci
/ be sure we actually have a connection
/ if not, wait for one
rs2, iot rcs
     rir 3s
     spi i
     jmp rs2

/ lock the send channel to 0 
     cli
     iot ssb
     say hl1
     say hl1b
     say hl1c

/ get the track to load
/ if there is an error, just return to the current program
try, say hl2
     lio (linbuf
     jda getaln
     spi
     jmp dcsfal
     lio (linbuf
     jda getnum
     spi i
     jmp getnld
     lai
     and (377
     sad ('h'
     jmp stp
     say badnum
     jmp try
stp, lio (sbcrst
     iot scb
     hlt

/ AC has the track to load
/ load bank 0 mem from drum
getnld,
     sal 6s
     sal 6s
     ior (drmrd
     lia
     iot dia
     cli
     iot dwc
     iot dcl

/ bank 0 now has pgm loaded, check for start
     lac (sadr
     dac ads
     lac i ads
     sza i
     jmp getnns

/ copy our bank 0 stuff again
     dzm adt
     lac (b0a
     ior (bnk
     dac ads
     law 4
     jda cpy

     lac (isr
     dac adt
     lac (b0b
     ior (bnk
     dac ads
     law 20
     jda cpy

     say bye
/ start 3 second countdown
     law 5670
     iot i cct
     cla
     iot cct

/ Close the channel, it will reopen on the next connection
     lio (sbcbnd
     iot scb
/ and transfer back to bank 0, adr 0
     jmp i b0s
b0s, 0

/ we had an error, just rebind and wait
dcsfal, lio (sbcbnd
     iot scb
     jmp resume

getnns, say badpgm
    jmp try

hl1, ascii "Hello from your PiDP1!\n"
hl1b, ascii "Once you select a program, this connection will close.\n"
hl1c, ascii "Open it again to select a new program.\n"

hl2, ascii "Program number to load, 0-31 or h to close all connections and halt? "

badnum, ascii "Sorry, that's not a valid number, try again.\n"

badpgm, ascii "That program has no start address, try again.\n"

bye, ascii "\nLoading program, then closing.\n"

/ Copy from one mem bank to another.
/ AC has the count of words to copy.
/ Location ads has the location in the source bank to copy from.
/ Location adt has the destination.
/ Both can have extended addresses.
/ If extended addresses are used, be sure an eem has been done first.
cpy, 0
    dap cd
    lac cpy
    cma
cl, add (1
    lsw
    lac i ads
    dac i adt
    idx ads
    idx adt
    lsw
    sza
    jmp cl
cd, jmp .
ads, 0
adt, 0

/ The channel 0 interrupt setup.
/ We execute a bit of code that will get
/ overwritten but reloaded on pgm switch.
b0a, lem
     jmp strt
     0
     jmp isr

/ The bank 0 control transfer back to bank 1
/ resides in the usual loader area starting at 7751.
b0b,
/ A connect request comes here, isr, 7751.
/ We have to jump thru hoops jumping to rti
/ because you can't enable extended mem while in
/ the interrupt and have it stick
     law 7754
     dac 1
     jmp i 1

/ The above ends up here, rtn, 7754. The jmp i 1 dismissed the interrupt.
/ Enable extened memory and  jump back to our control code.
/ We have to construct the address because we can't use a stored constant.
     law resume
     rcr 6s
     rcr 6s
     law bnkno
     rcl 6s
     rcl 6s
     dac 0
     eem
     jmp i 0

// The controller jumps here, strt, 7765, to start the program.
    cbs
    esm
    jmp i sadr

constants

/ We are started here in bank 0, copy our control program to the same locations in the bank
/ used for the control program, set up DCS2 and jump to 100 there.
6000/
/ force clear DCS2 in case user restarted here
    lio (sbcrst
    iot scb
    eem
    law 100
    dac ads
    ior (bnk
    dac adt
/ AC has the number of words to copy
    law 2000
    jda cpy

/ set up for interrupts, channel 0 for flex, echo, crnl, intr on state change
    cli
    lio (sbcset ctl
    iot scb 

    law 100
    ior (bnk
    dac ads
    jmp i ads

/ server port, ascii, echo, and crlf on channel 0, interrupt on connect or disconnect
/ listen on port 2022
ctl, dcfcrnl dcfecho dcfsrv dcfie dcfioe dcfioc
     decimal 2022
     octal

constants

start 6000
