SELECT AND RUN A DRUMLOADER PROGRAM VIA REMOTE CONNECTION ASCII VERSION

/ This uses the IOT 61 Drum implementation to query for, load,
/ and run a program from the drum.
/ It can also label a program, or list available programs.
/ When started, it copies its control code to bank 'bank', below,
/ When a program is requested, it copies the core image from the drum to bank 0 and
/ replaces the default binloader at 7751 with its bank 0 control code, 
/ It then sets up interrupt block 0, enables interrupts, closes the remote connection,
/ and transfers control to the program.
/ When a new connection comes in, it repeats the query for a new program to run.
/ If the loaded program halts or overwrites 7751 and up,
/ you can restart this at location 100 in the specified bank.
/ It also uses IOT 22, DCS2, and IOT 32, timesharing clock.

/ The few implemented PDP1-D instructions
/ Bit positions
liab=20
laib=40
lswb=60
swpb=60
cmib=4000
snib=4000
szib=14000
/ Instruction form
lia=760000 liab
lai=760000 laib
lsw=760000 lswb
swp=760000 swpb
cmi=760000 cmib
sni=640000 snib
szi=640000 szib

/ This defines the IOT instructions for the Type 23 drum.
/ Note this differs from the examples in that it does not add the iot
/ explicitly, so use is e.g. iot dia.
dia=61
dba=2061
dwc=62
dra=2062
dcl=63
dss=2063

/ Additional flags, not compatible with native macro, only macro1.
/ These flags are in the IO register.
drmrd=400000
drmwrt=400000

/ Bits for dss
drms16=40
drmsch=20

/ The bit set if a cks is done.
cksdrm=1

/ Defines for the DCS2 system.
/ See the documentation.
/ NOTE that rcr in DCS conflicts with rcr, rotate-combined-right.
/ It is renamed rchr here.
rch=0022
rrc=0122
rchr=1022
rsc=1122
tcb=4022
ssb=4122
tcc=5022

/ rch and rcr will clear the IO register if
/ this is added to the IOT, else it ors.
rchclr=002000

/ Extended commands.
rwe=0222
scb=4222
rle=4322
rpc=4422
rci=4522
ric=4622
rcs=4722
rwe=5122
roc=5222
res=5322
rxl=5422

/ symbols not compatible with native macro
/ dcfxxx are single bit flags
/ dcmxxx are multibit masks
/ Channel Request Block first word
/ dcfcrnl - turn newline into carriage return, newline on send
/ dcfflex - flexo mode, do automatic conversion
/ dcfecho - echo received characters
/ dcfioc - interrupt on connection open or close
/ dcfioe - interrupt on socket error
/ dcfior - interroupt on character received
/ dcfie -  enable interrupts for channel
/ dcfsrv - server mode
/ rxlfta - flexo to ascii
/ rxlucs - flexo upper case shift
/ rxlchg - flexo shift state changed
/ dcmsbs - bitmask, sbs channel to use
/ dcmcha - bitmask, channel number for this channel

dcfcrnl=400000
dcfflex=200000
dcfecho=100000
dcfioc=040000
dcfioe=020000
dcfior=010000
dcfie=004000
dcfsrv=000100
rxlfta=0400000
rxlucs=00400
rxlchg=01000

dcmsbs=003600
dcmcha=000077

// Directives to scb
sbcset=010000
sbcbnd=020000
sbcrst=040000
sbcclr=000000

/ Channel status flags
/ dsfopn - channel has been opened by scb
/ dsfsvr - channel is a server channel, else client
/ dsfcon - connected to remote host
/ dsfful - socket transmit buffer is full
/ dsfrdy - has characters ready to read
/ dsfser - got a socket error of some kine
/ dsfcls - remote closed connection
/ dsfien - interrupts are enabled
/ dsfior - interrupted because a character was received
/ dsfioc - interrupted because a connection was opened or closed
/ dsfioe - interrupted because transmit buffer full or other socket error
/ dsfcur - is the current channel

dsfopn=000001
dsfsvr=000002
dsfcon=000004
dsfful=000010
dsfrdy=000020
dsfser=000040
dsfcls=000100
dsfien=000200
dsfior=000400
dsfioc=001000
dsfioe=002000
dsfcur=004000

/ and some combined ones
dssrdy=dsfopn+dsfcon
dsserr=dsfcls+dsfser+dsfful

/ Errors returned in IO, dserr is the error flag
/ dseno - channel not open
/ dseoe - illegal operation on open channel
/ dseic - invalid channel number
/ dsens - server command on non-server channel
/ dseil - illegal command, commdand with illegal options
/ dseso - socket open or operation failed
/ dsebi - server bind to port failed
/ dsecc - rch, rcr, tcb, or tcc done but no current receive or send channel
/ dselo - remote end closed connection
/ dseep - internal error in epoll
/ dsenc - no client connected but operation attempted
dserr=400000
dseno=1
dseoe=2
dseic=3
dsens=4
dseil=5
dseso=6
dsebi=7
dsecc=10
dselo=11
dseep=12
dsenc=13

/ check status bit in IO reg
dcfcks=000200

/ special flex characters
flxerr=076
flxnch=013
flxetx=013
flxnl=077
/ ascnch is used by rxl
ascnch=077

/ Defines for the IOT_32 timesharing clock
/ Use as iot rck, etc.
/ rck - read 1ms clock
/ cls - set clock parameters
/ cct - set countdown timer

rck=32
cls=2032
cct=2132

/ Flags in AC for cls, not compatible with macro, only macro1
/ clss16 - enable SBS16, can't disable
/ clsena - enable clock, must be set to use, including clr
/ clsimn - enable minute interrupt
/ clsims - enable 32ms interrupt

cls16=4000
clsena=2000
clsimn=1000
clsims=400

/ And the channel masks
/ clfmmn - minute channel
/ clmffs - 32 millisecond channel
clfmmn=360
clfmms=17

/ NOTE for cct, enable SBS16 via iot cls cls16.
/ Flags in AC for cct, not compatible with macro, only macro1
/ cctie - enable interrupt

cctie=400000

/ And the channel and timer masks
/ cctich - interrupt channel
/ cctcnt - countdown timer
cctmch=360000
cctcnt=017777

/ The cks flag for the countdown timer
cctcks=040000


/ Which bank we load the control program into and its shifted value
bnk=10000
bnkno=1
isr=7751
rtn=7754
strt=7765
sadr=7773

/ A scratch buffer at 3000 is used for reading a line.
linbuf=3000

/ Put our included code bits here
1000/
/ Wait for an ascii character on the current DCS channel.
/ The IO register is cleared and the character is 
/ returned in the IO register.
/ If an error occurs, the IO register will be the rcs status with bit 0 set to 1.
/ The AC register is preserved.
/ Call via jda getach.




getach, 0
     dap gachrt
/ loop waiting for a character
gachlp,
     cli
     iot rcs
     lai
     and (dsfser dsfcls
     sza
     jmp gacher
     lai
     and (dsfrdy
     sza i
     jmp gachlp
     iot rch rchclr
     spi
     jmp gacher
     jmp gacdn
gacher,
     lai
     ior (400000
     lia
gacdn,
     lac getach
gachrt, jmp .

/ Read a line of ascii characters into the memory address passed in the IO register.
/ One character is placed in each word.
/ The line is terminated by the null character, 0, and the line terminatior (nl or cr) dropped.
/ The memory area is not bounds checked!
/ The current DCS2 channel is used.
/ If an error occurs, the IO register will have the DCS2 rcs error code, else 0.
/ The AC register is preserved.
/ Call via jda getaln.





getaln, 0
        dap glartn
        dio glamem
glalp,  jda getach
        lai
        sza i
        jmp glalp
        spa
        jmp glabad
        dio i glamem
        sad (15
        jmp gladon
        idx glamem
        jmp glalp
gladon, cli
/ overwrite the cr with 0
        dzm i glamem
glabad, lac getaln
glartn, jmp .
glamem, 0

/ Write a block of ascii text out.
/ Write out a string produced by ascii until a word containing
/ only 0 is seen, the starting address is in the ac,
/ ascii <whatever>
/
/ Include this before using it or declaring text that uses
/ the character defines, below.
/
/ Output goes to SBS channel 0 which must be in ascii mode.
/ On call, AC contains the address of the text block.
/ Insert this at the desired point in code.
/ Call via jda txtasc.




txtasc, 0
     dac txartn
txatop, lac i txtasc
/ a word has xaaaaaaaaxbbbbbbbb
     sar 4s
     sar 5s
     sza i
     jmp i txartn
     lia
     iot tcb
     law 377
     and i txtasc
     sza i
     jmp i txartn
     lia
     iot tcb
     idx txtasc
     jmp txatop
txartn, 0

/ Given a buffer of ascii digits, convert them to a binary number, return it in the AC.
/ Base-10 is used.
/ On call, the IO register contains the address of a buffer that contains one
/ ascii character per word.
/ Digits will be accumulated until a word of 0 is seen.
/ If any character other than '0'-'9' is seen, processing stops
/ and the number up to that point is returned.
/ The IO register will have bit 0 set to 1 and the low 8 bits will have the character.
/ The AC will have the number.
/ No overflow condition is detected, high bits will shift out in this case.
/ The maximum number is 98,304 unless AC is treated as unsigned, in which case it's 196,608.
getnum, 0
     dac getnrt
     dzm getnbr
     dio getnbf
getnlp, lio i getnbf
     lai
     sza i
     jmp getnok
     sub (60
     spa
     jmp getnbd
     sub (72-60
     spa i
     jmp getnbd
getndg,
/ multiply current number by 10 using a 3-bit shift (times 8) and 2 adds
     lac getnbr
     sal 3s
     add getnbr
     add getnbr
     dac getnbr
     lai
     sub (60
     add getnbr
     dac getnbr
     idx getnbf
     jmp getnlp
getnbd, lai
     ior (400000
     lia
     jmp .+2
getnok, cli
     lac getnbr
     jmp i getnrt
getnrt, 0
getnbr, 0
getnbf, 0


define say a
    law a
    ior (bnk
    jda txtasc
    term

define newline
    law 12
    lia
    iot tcb
    term

/ DCS2 is using channel interrupts
0/
    lem
    jmp strt
    0
    jmp isr

/ We don't initially start here, just convenient for copying to the extended bank.
/ The initial code will transfer here when done.
/ When running, the bank 0 code will transfer here on interrupt, a channel connect.
100/
resume, lsm
     cbs
     cli
     iot rci
/ be sure we actually open and have a connection
/ if not open, do so
/ if open and not connected, wait for one
rs2, cli
     iot rcs
     lai
     and (dsfopn
     sza
     jmp rs3
     lio (sbcset ctl
     iot scb

rs3, cli
     iot rcs
     lai
     and (dsfcon
     sza i
     jmp rs3

/ lock the send channel to 0 
     cli
     iot ssb
     say hl1
     say hl1b
     say hl1c

/ get the track to load or the command
/ if not valid, ask again
/ if a fatal error occurs, halt then rebind and go back to the connection wait
try, say hl2
     lio (linbuf
     jda getaln
     lai
     sza
     jmp dcsfal
     newline
     lio (linbuf
     jda getnum
/ AC has number, IO neg if no number, char in low bits
     spi i
     jmp getnld
     lai
     and (377
     sad (150
     jmp stp
     sad (154
     jmp list
     say badnum
     jmp try
stp, lio (sbcrst
     iot scb
     hlt
     jmp resume

/ List programs on the drum
/ Loop thru all tracks getting the control block, 7751-7777
list,
     newline
     dzm trk
lst2, lac trk
     sal 6s
     sal 6s
     ior (drmrd isr
     lia
     iot dia
     law 26
     lia
     iot dwc
     law linbuf
     ior (bnk
     lia
     iot dcl
     lac linbuf+25
     sad (707070
     jmp .+2
     jmp trkn
     jda prttrk
     say dir
     say linbuf
     newline
trkn, idx trk
     sad (040
     jmp try
     jmp lst2
trk, 0

/ AC has the track to load
/ load bank 0 mem from drum
getnld,
     sal 6s
     sal 6s
     ior (drmrd
     lia
     iot dia
     cli
     iot dwc
     iot dcl

/ bank 0 now has pgm loaded, check for valid load entry
     law 7777
     dac ads
     lac i ads
     sad (707070
     jmp trkok
     say inval
     jmp try

/ say the pgm, copy our bank 0 stuff again
trkok,
     say bye
/ show the directory filename
     law isr
     jda txtasc
     say bye2

/ copy our low mem code
     dzm adt
     lac (b0a
     ior (bnk
     dac ads
     law 4
     jda cpy

/ copy our high mem code
     law isr
     dac adt
     lac (b0b
     ior (bnk
     dac ads
     law 20
     jda cpy

/ start 2 second countdown
     law 3720
     iot i cct
     cla
     iot cct

/ Close the channel, it will reopen on the next connection
     lio (sbcbnd
     iot scb
/ be sure things are cleaned up interrupt-wise
     cbs
     cli
     iot rci
/ and transfer back to bank 0, adr 7765
     jmp i b0s
b0s, 7765

/ we had an error, just rebind and wait
dcsfal, lio (sbcbnd
     iot scb
     hlt
     jmp resume

hl1, / ascii
     110145
     154154
     157040
     146162
     157155
     040171
     157165
     162040
     120151
     104120
     061041
     012000

hl1b, / ascii
     117156
     143145
     040171
     157165
     040163
     145154
     145143
     164040
     141040
     160162
     157147
     162141
     155054
     040164
     150151
     163040
     143157
     156156
     145143
     164151
     157156
     040167
     151154
     154040
     143154
     157163
     145056
     012000

hl1c, / ascii
     117160
     145156
     040151
     164040
     141147
     141151
     156040
     164157
     040163
     145154
     145143
     164040
     141040
     156145
     167040
     160162
     157147
     162141
     155056
     012000

hl2, / ascii
     120162
     157147
     162141
     155040
     156165
     155142
     145162
     040164
     157040
     154157
     141144
     054040
     060055
     063061
     054040
     154040
     164157
     040154
     151163
     164040
     141166
     141151
     154141
     142154
     145054
     012157
     162040
     150040
     164157
     040143
     154157
     163145
     040141
     154154
     040143
     157156
     156145
     143164
     151157
     156163
     040141
     156144
     040150
     141154
     164077
     040000


dir, / ascii
     040055
     040000


badnum, / ascii
     123157
     162162
     171054
     040164
     150141
     164047
     163040
     156157
     164040
     141040
     166141
     154151
     144040
     156165
     155142
     145162
     054040
     164162
     171040
     141147
     141151
     156056
     012000

inval, / ascii
     124150
     141164
     040164
     162141
     143153
     040144
     157145
     163040
     156157
     164040
     150141
     166145
     040141
     040160
     162157
     147162
     141155
     040154
     157141
     144145
     144054
     040164
     162171
     040141
     147141
     151156
     056012
     000000


bye, / ascii
     012114
     157141
     144151
     156147
     040160
     162157
     147162
     141155
     040000

bye2, / ascii
     040164
     150145
     156040
     143154
     157163
     151156
     147056
     012000


/ Print the track number in location trk as 2 decimal digits.
prttrk, 0
    dap prtrtn
    cla
    lio trk
    sil 1s
    div (12
    add (60
    lsw
    iot tcb
    add (60
    lia
    iot tcb
prtrtn, jmp .

/ Copy from one mem bank to another.
/ AC has the count of words to copy.
/ Location ads has the location in the source bank to copy from.
/ Location adt has the destination.
/ Both can have extended addresses.
/ If extended addresses are used, be sure an eem has been done first.
cpy, 0
    dap cpydn
    lac cpy
    cma
cl, add (1
    lsw
    lac i ads
    dac i adt
    idx ads
    idx adt
    lsw
    sza
    jmp cl
cpydn, jmp .
ads, 0
adt, 0

/ server port, ascii, echo, and crlf on channel 0, interrupt on connect or disconnect
/ listen on port 2022
ctl, dcfcrnl dcfecho dcfsrv dcfie dcfioe dcfioc
     3746
     octal

// get our contants output so they don't step on us later
constants

/ The channel 0 interrupt setup.
/ We execute a bit of code that will get
/ overwritten but reloaded on pgm switch.
b0a, lem
     jmp strt
     0
     jmp isr

/ The bank 0 control transfer back to bank 1
/ resides in the usual loader area starting at 7751.
b0b,
/ A connect request comes here, isr, 7751.
/ We have to jump thru hoops jumping to rti
/ because you can't enable extended mem while in
/ the interrupt and have it stick
     law 7754
     dac 1
     jmp i 1

/ The above ends up here, rtn, 7754. The jmp i 1 dismissed the interrupt.
/ Enable extened memory and  jump back to our control code.
/ We have to construct the address because we can't use a stored constant.
     law resume
     rcr 6s
     rcr 6s
     law bnkno
     rcl 6s
     rcl 6s
     dac 0
     eem
     jmp i 0

/ The controller jumps here, strt, 7765, to start the program.
/ Be sure to not overwrite 7773-7777!
    lem
    esm
    jmp i sadr

constants

/ We are started here in bank 0, copy our control program imagefrom this bank to the same
/ locations in the bank  used for the control program and jump to 100 there.
/ Why all this hand-waving? Neither macro nor the default loader handles extended memory. Lame.
6000/
    eem
    law 100
    dac ads
    ior lclbnk
    dac adt
/ AC has the number of words to copy
    law 2000
    jda cpy

    law 100
    ior lclbnk
    dac ads
    jmp i ads
lclbnk, bnk

start 6000
