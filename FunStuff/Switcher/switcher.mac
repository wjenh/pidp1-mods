SELECT AND RUN A DRUMLOADER PROGRAM VIA REMOTE CONNECTION ASCII VERSION

/ This uses the IOT 61 Drum implementation to query for, load,
/ and run a program from the drum.
/ It can also label a program, or list available programs.
/ When started, it copies its control code to bank 'bank', below,
/ When a program is requested, it copies the core image from the drum to bank 0 and
/ replaces the default binloader at 7751 with its bank 0 control code, 
/ It then sets up interrupt block 0, enables interrupts, closes the remote connection,
/ and transfers control to the program.
/ When a new connection comes in, it repeats the query for a new program to run.
/ If the loaded program halts or overwrites 7751 and up,
/ you can restart this at location 100 in the specified bank.

/ The few implemented PDP1-D instructions
lia=760020
lai=760040
lsw=760060

/ This defines the IOT instructions for the Type 23 drum.
/ Note this differs from the examples in that it does not add the iot
/ explicitly, so use is e.g. iot dia.
dia=61
dba=2061
dwc=62
dra=2062
dcl=63
dss=2063

/ Additional flags, not compatible with native macro, only macro1.
/ These flags are in the IO register.
drmrd=400000
drmwrt=400000

/ Bits for dss
drms16=40
drmsch=20

/ The bit set if a cks is done.
cksdrm=1

/ Defines for the DCS2 system.
/ See the documentation.
/ NOTE that rcr in DCS conflicts with rcr, rotate-combined-right.
/ It is renamed rchr here.
rch=0022
rrc=0122
rchr=1022
rsc=1122
tcb=4022
ssb=4122
tcc=5022

/ rch and rcr will clear the IO register if
/ this is added to the IOT, else it ors.
rchclr=002000

/ Extended commands.
rwe=0222
scb=4222
rle=4322
rpc=4422
rci=4522
ric=4622
rcs=4722
roc=5222
res=5322

/ symbols not compatible with native macro
/ dcfxxx are single bit flags
/ dcmxxx are multibit masks
/ Channel Request Block first word
/ dcfcrnl - turn newline into carriage return, newline on send
/ dcfflex - flexo mode, do automatic conversion
/ dcfecho - echo received characters
/ dcfioc - interrupt on connection open or close
/ dcfioe - interrupt on socket error
/ dcfior - interroupt on character received
/ dcfie -  enable interrupts for channel
/ dcfsrv - server mode
/ dcmsbs - bitmask, sbs channel to use
/ dcmcha - bitmask, channel number for this channel

dcfcrnl=400000
dcfflex=200000
dcfecho=100000
dcfioc=040000
dcfioe=020000
dcfior=010000
dcfie=004000
dcfsrv=000100
dcmsbs=003600
dcmcha=000077

// Directives to scb
sbcset=010000
sbcbnd=020000
sbcrst=040000
sbcclr=000000

/ Channel status flags
/ dsfopn - channel has been opened by scb
/ dsfsvr - channel is a server channel, else client
/ dsfcon - connected to remote host
/ dsfful - socket transmit buffer is full
/ dsfrdy - has characters ready to read
/ dsfser - got a socket error of some kine
/ dsfcls - remote closed connection
/ dsfien - interrupts are enabled
/ dsfior - interrupted because a character was received
/ dsfioc - interrupted because a connection was opened or closed
/ dsfioe - interrupted because transmit buffer full or other socket error
/ dsfcur - is the current channel

dsfopn=000001
dsfsvr=000002
dsfcon=000004
dsfful=000010
dsfrdy=000020
dsfser=000040
dsfcls=000100
dsfien=000200
dsfior=000400
dsfioc=001000
dsfioe=002000
dsfcur=004000

/ and some combined ones
dssrdy=dsfopn+dsfcon
dsserr=dsfcls+dsfser+dsfful

/ Errors returned in IO, dserr is the error flag
/ dseno - channel not open
/ dseoe - illegal operation on open channel
/ dseic - invalid channel number
/ dsens - server command on non-server channel
/ dseil - illegal command, commdand with illegal options
/ dseso - socket open or operation failed
/ dsebi - server bind to port failed
/ dsecc - rch, rcr, tcb, or tcc done but no current receive or send channel
/ dselo - remote end closed connection
/ dseep - internal error in epoll
/ dsenc - no client connected but operation attempted
dserr=400000
dseno=1
dseoe=2
dseic=3
dsens=4
dseil=5
dseso=6
dsebi=7
dsecc=10
dselo=11
dseep=12
dsenc=13

/ check status bit in IO reg
dcfcks=000200

/ special flex characters
flxerr=076
flxnch=013
flxetx=013
flxnl=077

/ Defines for the IOT_32 timesharing clock
/ Use as iot rck, etc.
/ rck - read 1ms clock
/ cls - set clock parameters
/ cct - set countdown timer

rck=32
cls=2032
cct=2132

/ Flags in AC for cls, not compatible with macro, only macro1
/ clss16 - enable SBS16, can't disable
/ clsena - enable clock, must be set to use, including clr
/ clsimn - enable minute interrupt
/ clsims - enable 32ms interrupt

cls16=4000
clsena=2000
clsimn=1000
clsims=400

/ And the channel masks
/ clfmmn - minute channel
/ clmffs - 32 millisecond channel
clfmmn=360
clfmms=17

/ NOTE for cct, enable SBS16 via iot cls cls16.
/ Flags in AC for cct, not compatible with macro, only macro1
/ cctie - enable interrupt

cctie=400000

/ And the channel and timer masks
/ cctich - interrupt channel
/ cctcnt - countdown timer
cctmch=360000
cctcnt=017777

/ The cks flag for the countdown timer
cctcks=040000


/ Which bank we load the control program into
bnk=10000
bnkno=1
isr=7751
rtn=7754
strt=7765
sadr=7773

/ A scratch buffer at 500 is used for reading a line.
linbuf=500

/ Put our included code bits here
1000/
/ Wait for an ascii character on the current DCS channel.
/ The IO register is cleared and the character is 
/ returned in the IO register.
/ If an error occurs, the IO register will be 0.
/ The AC register is preserved.
/ Call via jda getach.




getach, 0
     dac gachrt
/ loop waiting for a character
gachlp,
     cli
     iot rcs
     lai
     and (dsfful dsfser dsfcls
     sza
     jmp gacher
     lai
     and (dsfrdy
     sza i
     jmp gachlp
     iot rch rchclr
     lai
     spi
/ really shouldn't happen
     jmp gachlp
/ the character in IO is either valid or 0
     jmp .+2
gacher,
     cli
     lac getach
     jmp i gachrt
gachrt, 0

/ Read a line of ascii characters into the memory address passed in the IO register.
/ One character is placed in each word.
/ The line is terminated by the null character, 0, and the line terminatior (nl or cr) dropped.
/ The memory area is not bounds checked!
/ The current DCS2 channel is used.
/ If an error occurs, the IO register will have the DCS2 error code, else 0.
/ The AC register is preserved.
/ Call via jda getaln.





getaln, 0
        dac glartn
        dio glamem
glalp,  jda getach
        lai
        spa
        jmp glabad
        dio i glamem
        sad (15
        jmp gladon
        sad (12
        jmp gladon
        idx glamem
        jmp glalp
gladon, lac getaln
        cli
/ overwrite the cr or nl with 0
        dzm i glamem
        jmp i glartn
glabad, iot rle
        lac getaln
        jmp i glartn
glartn, 0
glamem, 0

/ Write a block of ascii text out.
/ Write out a string produced by ascii until a word containing
/ only 0 is seen, the starting address is in the ac,
/ ascii <whatever>
/
/ Include this before using it or declaring text that uses
/ the character defines, below.
/
/ Output goes to SBS channel 0 which must be in ascii mode.
/ On call, AC contains the address of the text block.
/ Insert this at the desired point in code.
/ Call via jda txtasc.




txtasc, 0
     dac txartn
txatop, lac i txtasc
/ a word has xaaaaaaaaxbbbbbbbb
     sar 4s
     sar 5s
     sza i
     jmp i txartn
     lia
     iot tcb
     law 377
     and i txtasc
     sza i
     jmp i txartn
     lia
     iot tcb
     idx txtasc
     jmp txatop
txartn, 0

/ Given a buffer of ascii digits, convert them to a binary number, return it in the AC.
/ Base-10 is used.
/ On call, the IO register contains the address of a buffer that contains one
/ ascii character per word.
/ Digits will be accumulated until a word of 0 is seen.
/ If any character other than '0'-'9' is seen, processing stops
/ and the number up to that point is returned.
/ The IO register will have bit 0 set to 1 and the low 8 bits will have the character.
/ No overflow condition is detected, high bits will shift out in this case.
/ The maximum number is 98,304 unless AC is treated as unsigned, in which case it's 196,608.
getnum, 0
     dac getnrt
     dzm getnbr
     dio getnbf
getnlp, lio i getnbf
     lai
     sza i
     jmp getnok
     sub (60
     spa
     jmp getnbd
     sub (72-60
     spa i
     jmp getnbd
getndg,
/ multiply current number by 10 using a 3-bit shift (times 8) and 2 adds
     lac getnbr
     sal 3s
     add getnbr
     add getnbr
     dac getnbr
     lai
     sub (60
     add getnbr
     dac getnbr
     idx getnbf
     jmp getnlp
getnbd, lai
     ior (400000
     lia
     jmp .+2
getnok, cli
     lac getnbr
     jmp i getnrt
getnrt, 0
getnbr, 0
getnbf, 0




define say a
    law a
    ior (bnk
    jda txtasc
    term

/ DCS2 is using channel interrupts
0/
    lem
    jmp strt
    0
    jmp isr

/ We don't initially start here, just convenient for copying to the extended bank.
/ When running, the bank 0 code will transfer here on interrupt, a channel connect.
100/
resume, lsm
     cbs
     cli
     iot rci
/ be sure we actually have a connection
/ if not, wait for one
rs2, iot rcs
     rir 3s
     spi i
     jmp rs2

/ lock the send channel to 0 
     cli
     iot ssb
     say hl1
     say hl1b
     say hl1c

/ get the track to load
/ if there is an error, just return to the current program
try, say hl2
     lio (linbuf
     jda getaln
     spi
     jmp dcsfal
     lio (linbuf
     jda getnum
     spi i
     jmp getnld
     lai
     and (377
     sad (150
     jmp stp
     say badnum
     jmp try
stp, lio (sbcrst
     iot scb
     hlt

/ AC has the track to load
/ load bank 0 mem from drum
getnld,
     sal 6s
     sal 6s
     ior (drmrd
     lia
     iot dia
     cli
     iot dwc
     iot dcl

/ bank 0 now has pgm loaded, check for start
     lac (sadr
     dac ads
     lac i ads
     sza i
     jmp getnns

/ copy our bank 0 stuff again
     dzm adt
     lac (b0a
     ior (bnk
     dac ads
     law 4
     jda cpy

     lac (isr
     dac adt
     lac (b0b
     ior (bnk
     dac ads
     law 20
     jda cpy

     say bye
/ start 3 second countdown
     law 5670
     iot i cct
     cla
     iot cct

/ Close the channel, it will reopen on the next connection
     lio (sbcbnd
     iot scb
/ and transfer back to bank 0, adr 0
     jmp i b0s
b0s, 0

/ we had an error, just rebind and wait
dcsfal, lio (sbcbnd
     iot scb
     jmp resume

getnns, say badpgm
    jmp try

hl1, / ascii
    110145
    154154
    157040
    146162
    157155
    040171
    157165
    162040
    120151
    104120
    061041
    012000

hl1b, / ascii
    117156
    143145
    040171
    157165
    040163
    145154
    145143
    164040
    141040
    160162
    157147
    162141
    155054
    040164
    150151
    163040
    143157
    156156
    145143
    164151
    157156
    040167
    151154
    154040
    143154
    157163
    145056
    012000

hl1c, / ascii
    117160
    145156
    040151
    164040
    141147
    141151
    156040
    164157
    040163
    145154
    145143
    164040
    141040
    156145
    167040
    160162
    157147
    162141
    155056
    012000


hl2, / ascii
    120162
    157147
    162141
    155040
    156165
    155142
    145162
    040164
    157040
    154157
    141144
    054040
    060055
    063061
    040157
    162040
    150040
    164157
    040143
    154157
    163145
    040141
    154154
    040143
    157156
    156145
    143164
    151157
    156163
    040141
    156144
    040150
    141154
    164077
    040000


badnum, / ascii
    123157
    162162
    171054
    040164
    150141
    164047
    163040
    156157
    164040
    141040
    166141
    154151
    144040
    156165
    155142
    145162
    054040
    164162
    171040
    141147
    141151
    156056
    012000


badpgm, / ascii
    124150
    141164
    040160
    162157
    147162
    141155
    040150
    141163
    040156
    157040
    163164
    141162
    164040
    141144
    144162
    145163
    163054
    040164
    162171
    040141
    147141
    151156
    056012
    000000


bye, / ascii
    012114
    157141
    144151
    156147
    040160
    162157
    147162
    141155
    054040
    164150
    145156
    040143
    154157
    163151
    156147
    056012
    000000


/ Copy from one mem bank to another.
/ AC has the count of words to copy.
/ Location ads has the location in the source bank to copy from.
/ Location adt has the destination.
/ Both can have extended addresses.
/ If extended addresses are used, be sure an eem has been done first.
cpy, 0
    dap cd
    lac cpy
    cma
cl, add (1
    lsw
    lac i ads
    dac i adt
    idx ads
    idx adt
    lsw
    sza
    jmp cl
cd, jmp .
ads, 0
adt, 0

/ The channel 0 interrupt setup.
/ We execute a bit of code that will get
/ overwritten but reloaded on pgm switch.
b0a, lem
     jmp strt
     0
     jmp isr

/ The bank 0 control transfer back to bank 1
/ resides in the usual loader area starting at 7751.
b0b,
/ A connect request comes here, isr, 7751.
/ We have to jump thru hoops jumping to rti
/ because you can't enable extended mem while in
/ the interrupt and have it stick
     law 7754
     dac 1
     jmp i 1

/ The above ends up here, rtn, 7754. The jmp i 1 dismissed the interrupt.
/ Enable extened memory and  jump back to our control code.
/ We have to construct the address because we can't use a stored constant.
     law resume
     rcr 6s
     rcr 6s
     law bnkno
     rcl 6s
     rcl 6s
     dac 0
     eem
     jmp i 0

// The controller jumps here, strt, 7765, to start the program.
    cbs
    esm
    jmp i sadr

constants

/ We are started here in bank 0, copy our control program to the same locations in the bank
/ used for the control program, set up DCS2 and jump to 100 there.
6000/
/ force clear DCS2 in case user restarted here
    lio (sbcrst
    iot scb
    eem
    law 100
    dac ads
    ior (bnk
    dac adt
/ AC has the number of words to copy
    law 2000
    jda cpy

/ set up for interrupts, channel 0 for flex, echo, crnl, intr on state change
    cli
    lio (sbcset ctl
    iot scb 

    law 100
    ior (bnk
    dac ads
    jmp i ads

/ server port, ascii, echo, and crlf on channel 0, interrupt on connect or disconnect
/ listen on port 2022
ctl, dcfcrnl dcfecho dcfsrv dcfie dcfioe dcfioc
     decimal 2022
     octal

constants

start 6000
