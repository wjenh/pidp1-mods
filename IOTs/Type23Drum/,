#include <unistd.h>
#include <fcntl.h>

#include "common.h"
#include "pdp1.h"
#include "iotHandler.h"

#define DOLOGGING
#include "Logger/iotLogger.h"

// flags for busy, done for the cks instruction
// DRP is busy, DRM is done
// from the simh PDP-1 drum implementation
#define CKS_DRP 0400000
#define CKS_DRM 0000040

/*
 * This is an implementation of the PDP-1 Type 23 Parallel Drum.
 * It keeps the drum data in a file named 'pdp23drum'.
 * The drum also uses IOTs 62 and 63, so replicate into those.
 */

#define DRUMFILE "/tmp/pdp23drum"
#define DRUMADDRTOSEEK(field, offset) (((field * 4096) + (offset)) * sizeof(Word))

static int drumFd = -1;
static int drumReadField;
static int drumWriteField;
static int drumAddr;
static int transferCount;
static int drumCount;
static int readMode;
static int writeMode;
static int ioBusy;
static int needBreak;
static int inWait;
static u64 lastSimtime;         // used in the polling code for drumcount updates
static u64 cmdCompletionTime;   // relative to pdp1P->simtime

static int memBank;
static int memAddr;

static void readDrumToBuffer(int, Word *, int, int, int);
static void writeBufferToDrum(int, Word *, int, int, int);
static void copyMemToBuffer(Word *, Word *, int, int);
static void copyBufferToMem(Word *, Word *, int, int);

int
iotHandler(PDP1 *pdp1P, int dev, int pulse, int completion)
{
int i;
Word *memBaseP;
Word readBuf[4096];                 // needed for read/write mode

    if( pulse )
    {
        return(1);                  // only on one edge
    }

    iotLog("In iot 61 as %o\n", dev);

    if( drumFd < 0 )
    {
        iotLog("In iot 61, no drumFd\n");
        return(0);                 // sorry, some error with the drum file
    }

    lastSimtime = pdp1P->simtime;
    enablePolling(1);
    inWait = completion;            // if nonzero, we will be in IOT wait state

    switch( dev )
    {
    case 061:            // dia, drum initial address, in the IO register, or dba, drum break address
        needBreak = ioBusy = 0;             // just to be sure
        pdp1P->cksflags &= ~(CKS_DRP | CKS_DRM);    // and not busy or done

        readMode = pdp1P->io & 0400000;
        writeMode = 0;
        drumAddr = pdp1P->io & 07777;
        drumReadField = (pdp1P->io & 0370000) >> 12;

        if( inWait )                    // we don't want to be
        {
            inWait = 0;
            IOCOMPLETE(pdp1P);
        }

        if( pdp1P->mb & 02000 )
        {
            // dba, using the interrupt system. reqiest break
            // The break happens when the drumCount == the drumAddr
            needBreak = 1;
            iotLog("dba, break on %o\n", drumAddr);
        }
        
        iotLog("dia done, read %d, rfield %d, daddr %d\n", readMode, drumReadField, drumAddr);
        break;

    case 062:            // dwc, drum word count or dra, drum request address
        if( pdp1P->mb & 02000 )
        {
            // dra, return current drum 'counter' in the IO register, along with status
            pdp1P->io = drumCount;
            iotLog("dra drum count %o\n", drumCount);
        }
        else
        {
            writeMode = pdp1P->io & 0400000;
            drumWriteField = (pdp1P->io >> 12) & 037;
            drumWriteField = (pdp1P->io & 0370000) >> 12;
            transferCount = pdp1P->io & 07777;

            iotLog("dwc done, write %d, wfield %d, count %o\n", writeMode, drumWriteField, transferCount);
            pdp1P->cksflags &= ~CKS_DRM;    // not done now
        }

        if( inWait )                    // we don't want to be
        {
            inWait = 0;
            IOCOMPLETE(pdp1P);
        }
        break;

    case 063:            // dcl, drum core location
        memBank = (pdp1P->io >> 14) & 03;
        memAddr = pdp1P->io & 017777;

        iotLog("dcl memBank %o memAddr %o\n", memBank, memAddr);

        memBaseP = &pdp1P->core[(memBank % 037) * 4096];

        // and away we go
        // We might have read/write mode, in which case we have to read the data first
        // Both the drum address and the memory address can wrap around

        if( readMode && writeMode )
        {
            // First we read the drum, but don't put it in memory yet
            // we need 2 buffer, though
            readDrumToBuffer(drumFd, readBuf, drumReadField, drumAddr, transferCount);
            Word writeBuf[4096];
            copyMemToBuffer(writeBuf, memBaseP, memAddr, transferCount);
            writeBufferToDrum(drumFd, writeBuf, drumWriteField, drumAddr, transferCount);

            // Now we can overwrite mem with the drum data

            copyBufferToMem(readBuf, memBaseP, memAddr, transferCount);
        }
        else if( readMode )            // just a regular read
        {
            readDrumToBuffer(drumFd, readBuf, drumReadField, drumAddr, transferCount);
            copyBufferToMem(readBuf, memBaseP, memAddr, transferCount);
        }
        else if( writeMode )
        {
            // We can use readbuf for this
            copyMemToBuffer(readBuf, memBaseP, memAddr, transferCount);
            writeBufferToDrum(drumFd, readBuf, drumWriteField, drumAddr, transferCount);
        }
        else
        {
            // hmm, not read or write. Do what?
            return(1);
        }

        ioBusy = 1;
        pdp1P->cksflags |= CKS_DRP;
        cmdCompletionTime = transferCount;

        // We might be in IO wait, not sure if it's correct to actually wait, but we will.

        if( drumAddr < drumCount )  // have to wait for it to come around again on the guitar
        {
            cmdCompletionTime += 4096 - drumCount + drumAddr;
        }
        else
        {
            cmdCompletionTime += drumCount - drumAddr;
        }

        cmdCompletionTime = pdp1P->simtime + cmdCompletionTime * 8500;
        iotLog("dcl done\n");
        break;

    default:
        return(0);                // should never happen
    }

    return(1);
}

void
iotStart()
{
    iotLog("IOT 61 started\n");
    if( drumFd < 0 )
    {
        drumFd = open(DRUMFILE, O_RDWR + O_CREAT + O_SYNC, 0666);
        iotLog("IOT 61 drumFd = %d\n", drumFd);
    }

    needBreak = 0;
    drumCount = 0;  // we don't really know where the hardware would have been, just use 0
}

void
iotStop()
{
    iotCloseLog();

    if( drumFd >= 0 )
    {
        close(drumFd);
        drumFd = -1;
    }
}

// Used to update drumCount, trigger a break,  determine the end of a transfer
void
iotPoll(PDP1 *pdp1P)
{
    if( ioBusy )
    {
        if( pdp1P->simtime >= cmdCompletionTime )
        {
            ioBusy = 0;
            pdp1P->cksflags |= CKS_DRM;     // done
            pdp1P->cksflags &= ~CKS_DRP;    // and not busy
            drumCount = (drumAddr + transferCount) % 4096;   // sync up the drum count to match the end of the transfer

            if( inWait )
            {
                inWait = 0;
                IOCOMPLETE(pdp1P);
            }

            iotLog("IOT 61 completed timeout.\n");
        }
    }
    else
    {
        // The original hardware updated this every 8.5us, be we aren't called with that timing.
        // So the count is updated when simtime % 8500 is zero.
        // This won't be exact, but the longer the time but the higher the count, the more accurate it will be.
        // The worst case will be a 10us interval.

        if( pdp1P->simtime >= (lastSimtime + 8500) )
        {
            lastSimtime = pdp1P->simtime;
            drumCount = ++drumCount % 4096;
        }

        if( needBreak && (drumCount == drumAddr) )
        {
            ioBusy = needBreak = 0;
            pdp1P->cksflags |= CKS_DRM;     // done
            pdp1P->cksflags &= ~CKS_DRP;    // and not busy
            initiateBreak(0);           // no channel specified, what to use for sbs16? Is 0 correct??
            iotLog("IOT 61 break initiated at drum count %o.\n", drumCount);
        }
    }
}

// Do a drum read handling drum wraparound
static void
readDrumToBuffer(
    int drumFd,         // file descriptor for our 'drum'
    Word *buffer,       // must be at least 4096, anything over is unused
    int drumField,      // which 4K block on drum
    int drumAddr,       // start point relative to drum index
    int transferCount)  // number of words to transfer
{
int drumSplitCount = 0;
int drumRemainderCount = 0;

    if( (drumAddr + transferCount) > 4095 )
    {
        drumSplitCount = 4096 - drumAddr;   // we transfer this many before wraparound
        drumRemainderCount = transferCount - drumSplitCount;
    }
    else
    {
        drumSplitCount = transferCount;
        drumRemainderCount = 0;
    }

    iotLog("read drum to buffer, drumSplitCount %d, drumRemainderCount %d\n", drumSplitCount, drumRemainderCount);

    lseek(drumFd, DRUMADDRTOSEEK(drumField, drumAddr), SEEK_SET);
    // a read fail is ok, could be an uninitialized drum block. Mem gets buffer content.
    read(drumFd, buffer, sizeof(Word) * drumSplitCount);
    if( drumRemainderCount )
    {
        lseek(drumFd, DRUMADDRTOSEEK(drumField, 0), SEEK_SET);
        read(drumFd, buffer + drumSplitCount, sizeof(Word) * drumRemainderCount);
    }
}

// Do a drum write handling drum wraparound
static void
writeBufferToDrum(
    int drumFd,         // file descriptor for our 'drum'
    Word *buffer,       // must be at least 4096, anything over is unused
    int drumField,      // which 4K block on drum
    int drumAddr,       // start point relative to drum index
    int transferCount)  // number of words to transfer
{
int drumSplitCount = 0;
int drumRemainderCount = 0;

    if( (drumAddr + transferCount) > 4095 )
    {
        drumSplitCount = 4096 - drumAddr;   // we transfer this many before wraparound
        drumRemainderCount = transferCount - drumSplitCount;
    }
    else
    {
        drumSplitCount = transferCount;
        drumRemainderCount = 0;
    }

    iotLog("write buffer to drum, drumSplitCount %d, drumRemainderCount %d\n", drumSplitCount, drumRemainderCount);

    lseek(drumFd, DRUMADDRTOSEEK(drumField, drumAddr), SEEK_SET);
    write(drumFd, buffer, sizeof(Word) * drumSplitCount);
    if( drumRemainderCount )
    {
        iotLog("writing remainder from buffer location %d to disk offset %o\n", drumSplitCount,
            DRUMADDRTOSEEK(drumField, 0));
        lseek(drumFd, DRUMADDRTOSEEK(drumField, 0), SEEK_SET);
        write(drumFd, buffer + drumSplitCount, sizeof(Word) * drumRemainderCount);
    }
}

// Copy a buffer to memory handling memory wraparound
static void
copyBufferToMem(
    Word *buffer,       // must be at least 4096, anything over is unused
    Word *memBaseP,      // address addr 0 in desired bank
    int memAddr,        // word offset in current bank
    int transferCount)  // number of words to transfer
{
int i, j;

    iotLog("copy buffer to mem, memAddr %d, transferCount %d\n", memAddr, transferCount);

    for( i = memAddr, j = 0; transferCount--; i = (i + 1) % 4096 )
    {
        *(memBaseP + i) = *(buffer + j++);
    }
}

// Copy memory to buffer handling memory wraparound
static void
copyMemToBuffer(
    Word *buffer,       // must be at least 4096, anything over is unused
    Word *memBaseP,      // address addr 0 in desired bank
    int memAddr,        // word offset in current bank
    int transferCount)  // number of words to transfer
{
int i, j;

    iotLog("copy mem to buffer, memAddr %d, transferCount %d\n", memAddr, transferCount);

    for( i = memAddr, j = 0; transferCount--; i = (i + 1) % 4096 )
    {
        *(buffer + j++) = *(memBaseP + i);
    }
}
