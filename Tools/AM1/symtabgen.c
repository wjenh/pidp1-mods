/*
 * symtabgen.c - generate a C file that is a pre-populated symbol table of all the opcodes and special values.
 * Usage: symtabgen deffile
 * A file with a name of the input definiton file with '.c' appended  will be created containing the symbol table,
 * the global symbol pointer will be permSymP.
 *
 * The format of a line is:
 * # a comment, ignored, as are blank lines.
 * name type value trailing-chars-ignored.
 * where name is the symbol name,
 * type is one of 'value', 'opcode', 'opaddr', or 'oporable'
 * and value is the integer value.
*/
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <string.h>

#include "symtab.h"
#include "am1.h"

int nodeno;                                         // which symbol node we have, for emit_nodes()
int emit_nodes(SymNodeP, FILE *);

int main( int argc, char **argv )
{
int i;
int lineno;                                     // current line in deffile
int rootid;                                     // root node of symtab
int curValue;                                   // current symbol value
char *cP, *cP2;                                 // misc char ptrs
char *extnameP;                                 // the current symbol name
char *typeP;                                    // the current type
FILE *infileP;                                  // what we read
FILE *outfP;                                    // where the generated file goes
SymNodeP symtabP;                               // our symbol table
SymNodeP newsymP;                               // newly allocated node
char infile[1024];
char outfile[1024];
char line[1024];                                // and a line buffer

    if( argc != 2 )
    {
        fprintf( stderr, "Usage: symtabgen deffile\n" );
        exit( 1 );
    }

    strcpy(infile, argv[1]);
    if( !(infileP = fopen(infile, "r")) )
    {
        fprintf( stderr, "btagben: can't open file '%s' for reading.\n", infile );
        exit( 1 );
    }

    strcpy( outfile, infile );
    strcat( outfile, ".c" );
    if( !(outfP = fopen(outfile, "w")) )
    {
        fprintf( stderr, "symtabgen: can't create '%s'\n", outfile );
        exit( 1 );
    }

    // Ok, done with the formalities, start processing
    sym_init( &symtabP );
    lineno = 0;

    fprintf(outfP, "/* %s - generated symbol table\n", outfile);
    fputs(" *\n", outfP);
    fputs(" * This is an array of nodes which make up the symbol table\n", outfP);
    fprintf(outfP, " * generated by symtabgen from %s.\n", infile);
    fputs(" *\n", outfP);
    fputs(" */\n\n", outfP);
    fputs("#include \"symtab.h\"\n\n", outfP);

    while( fgets(line, sizeof(line), infileP) )
    {
        ++lineno;

        // ignore extra white space everywhere
        for( extnameP = line; isspace(*extnameP); ++extnameP )
            ;

        if( !*extnameP || (*extnameP == '#') )
        {
            continue;                               // a comment or empty line
        }

        for( cP = extnameP; isalpha(*cP) || isdigit(*cP); ++cP )
            ;

        *cP++ = '\0';                               // terminates extname

        // now the type
        while( isspace(*cP) )
        {
            ++cP;
        }

        typeP = cP;
        while( isalpha(*cP) || isdigit(*cP) )
        {
            ++cP;
        }

        *cP++ = '\0';                               // terminates type

        if( !strcmp(typeP, "opcode") )
        {
            i = SYMF_PERM | SYM_OPCODE;
        }
        else if( !strcmp(typeP, "opaddr") )
        {
            i = SYMF_PERM | SYM_OPADDR;
        }
        else if( !strcmp(typeP, "oporable") )
        {
            i = SYMF_PERM | SYM_OPORABLE;
        }
        else if( !strcmp(typeP, "value") )
        {
            i = SYMF_PERM | SYM_VALUE;
        }
        else
        {
            fprintf( stderr, "symtabgen: invalid type '%s' at line %d.\n", typeP, lineno );
            exit( 1 );
        }

        // now the value
        curValue = strtol(cP, &cP2, 0);
        if( cP == cP2 )
        {
            fprintf( stderr, "symtabgen: invalid value '%s' at line %d.\n", cP, lineno );
            exit( 1 );
        }

        if( sym_find(&symtabP, extnameP) )          // dup name
        {
            fprintf( stderr, "symtabgen: duplicate name '%s' at line %d.\n", extnameP, lineno );
            exit( 1 );
        }

        // Make a new entry for the symbol table.
        
        newsymP = sym_make(extnameP, 0);
        sym_add( &symtabP, newsymP );
        newsymP->value = curValue;
        newsymP->flags = i;
    }

    fclose( infileP );

    // Ok, if we get here, we've read in all of the defs.
    // We need to generate a static mess that ends up looking like a binary symbol tree.
    fprintf(outfP, "SymNode perm_symtab[] = {");
    rootid = emit_nodes(symtabP, outfP);
    fprintf(outfP, "\n};\n\n");

    fprintf(outfP, "SymNodeP permSymP = &perm_symtab[%d];\n", rootid );

    // and now we're all done
    fclose( outfP );
    exit( 0 );
}

// Infix walk the table, emit symtab nodes as symbol table C code.

int
emit_nodes(SymNodeP nodeP, FILE *fP)
{
int leftid;         // the array offset of left child
int rightid;        // the array offset of right child

    if( nodeP->leftP )
    {
        leftid = emit_nodes(nodeP->leftP, fP);
    }
    else
    {
        leftid = -1;
    }

    if( nodeP->rightP )
    {
        rightid = emit_nodes(nodeP->rightP, fP);
    }
    else
    {
        rightid = -1;
    }

    // emit the entry contents
    fprintf(fP, "%s\n    {\n", nodeno ? "," : "");

    if( leftid != -1 )
    {
        fprintf(fP, "        &perm_symtab[%d],", leftid );
    }
    else
    {
        fprintf(fP, "        0,");
    }

    if( rightid != -1 )
    {
        fprintf(fP, "&perm_symtab[%d],", rightid );
    }
    else
    {
        fprintf(fP, "0,");
    }

    fprintf(fP, "\"%s\",0,0x%x,0,%07o,0,0,0    // %d\n", nodeP->name, nodeP->flags, nodeP->value, nodeno);
    fprintf(fP, "    }");

    return( nodeno++ );
}
